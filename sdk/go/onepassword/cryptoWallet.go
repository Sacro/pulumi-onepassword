// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package onepassword

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-onepassword/sdk/go/onepassword/cryptowallet"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type CryptoWallet struct {
	pulumi.CustomResourceState

	Category       pulumi.StringOutput    `pulumi:"category"`
	Fields         GetFieldArrayOutput    `pulumi:"fields"`
	Id             pulumi.StringOutput    `pulumi:"id"`
	Notes          pulumi.StringPtrOutput `pulumi:"notes"`
	Password       pulumi.StringPtrOutput `pulumi:"password"`
	RecoveryPhrase pulumi.StringPtrOutput `pulumi:"recoveryPhrase"`
	Sections       GetSectionArrayOutput  `pulumi:"sections"`
	// An array of strings of the tags assigned to the item.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The title of the item.
	Title pulumi.StringOutput `pulumi:"title"`
	// The UUID of the item to retrieve. This field will be populated with the UUID of the item if the item it looked up by its title.
	Uuid pulumi.StringOutput `pulumi:"uuid"`
	// The UUID of the vault the item is in.
	Vault  pulumi.StringOutput          `pulumi:"vault"`
	Wallet cryptowallet.WalletPtrOutput `pulumi:"wallet"`
}

// NewCryptoWallet registers a new resource with the given unique name, arguments, and options.
func NewCryptoWallet(ctx *pulumi.Context,
	name string, args *CryptoWalletArgs, opts ...pulumi.ResourceOption) (*CryptoWallet, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Title == nil {
		return nil, errors.New("invalid value for required argument 'Title'")
	}
	if args.Vault == nil {
		return nil, errors.New("invalid value for required argument 'Vault'")
	}
	if isZero(args.Category) {
		args.Category = pulumi.String("Item")
	}
	var resource CryptoWallet
	err := ctx.RegisterResource("onepassword:index:CryptoWallet", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCryptoWallet gets an existing CryptoWallet resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCryptoWallet(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CryptoWalletState, opts ...pulumi.ResourceOption) (*CryptoWallet, error) {
	var resource CryptoWallet
	err := ctx.ReadResource("onepassword:index:CryptoWallet", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CryptoWallet resources.
type cryptoWalletState struct {
}

type CryptoWalletState struct {
}

func (CryptoWalletState) ElementType() reflect.Type {
	return reflect.TypeOf((*cryptoWalletState)(nil)).Elem()
}

type cryptoWalletArgs struct {
	Category       string    `pulumi:"category"`
	Fields         []Field   `pulumi:"fields"`
	Notes          *string   `pulumi:"notes"`
	Password       *string   `pulumi:"password"`
	RecoveryPhrase *string   `pulumi:"recoveryPhrase"`
	Sections       []Section `pulumi:"sections"`
	// An array of strings of the tags assigned to the item.
	Tags []string `pulumi:"tags"`
	// The title of the item to retrieve. This field will be populated with the title of the item if the item it looked up by its UUID.
	Title string `pulumi:"title"`
	// The UUID of the vault the item is in.
	Vault  string               `pulumi:"vault"`
	Wallet *cryptowallet.Wallet `pulumi:"wallet"`
}

// The set of arguments for constructing a CryptoWallet resource.
type CryptoWalletArgs struct {
	Category       pulumi.StringInput
	Fields         FieldArrayInput
	Notes          pulumi.StringPtrInput
	Password       pulumi.StringPtrInput
	RecoveryPhrase pulumi.StringPtrInput
	Sections       SectionArrayInput
	// An array of strings of the tags assigned to the item.
	Tags pulumi.StringArrayInput
	// The title of the item to retrieve. This field will be populated with the title of the item if the item it looked up by its UUID.
	Title pulumi.StringInput
	// The UUID of the vault the item is in.
	Vault  pulumi.StringInput
	Wallet cryptowallet.WalletPtrInput
}

func (CryptoWalletArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cryptoWalletArgs)(nil)).Elem()
}

type CryptoWalletInput interface {
	pulumi.Input

	ToCryptoWalletOutput() CryptoWalletOutput
	ToCryptoWalletOutputWithContext(ctx context.Context) CryptoWalletOutput
}

func (*CryptoWallet) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoWallet)(nil)).Elem()
}

func (i *CryptoWallet) ToCryptoWalletOutput() CryptoWalletOutput {
	return i.ToCryptoWalletOutputWithContext(context.Background())
}

func (i *CryptoWallet) ToCryptoWalletOutputWithContext(ctx context.Context) CryptoWalletOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoWalletOutput)
}

// CryptoWalletArrayInput is an input type that accepts CryptoWalletArray and CryptoWalletArrayOutput values.
// You can construct a concrete instance of `CryptoWalletArrayInput` via:
//
//	CryptoWalletArray{ CryptoWalletArgs{...} }
type CryptoWalletArrayInput interface {
	pulumi.Input

	ToCryptoWalletArrayOutput() CryptoWalletArrayOutput
	ToCryptoWalletArrayOutputWithContext(context.Context) CryptoWalletArrayOutput
}

type CryptoWalletArray []CryptoWalletInput

func (CryptoWalletArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CryptoWallet)(nil)).Elem()
}

func (i CryptoWalletArray) ToCryptoWalletArrayOutput() CryptoWalletArrayOutput {
	return i.ToCryptoWalletArrayOutputWithContext(context.Background())
}

func (i CryptoWalletArray) ToCryptoWalletArrayOutputWithContext(ctx context.Context) CryptoWalletArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoWalletArrayOutput)
}

// CryptoWalletMapInput is an input type that accepts CryptoWalletMap and CryptoWalletMapOutput values.
// You can construct a concrete instance of `CryptoWalletMapInput` via:
//
//	CryptoWalletMap{ "key": CryptoWalletArgs{...} }
type CryptoWalletMapInput interface {
	pulumi.Input

	ToCryptoWalletMapOutput() CryptoWalletMapOutput
	ToCryptoWalletMapOutputWithContext(context.Context) CryptoWalletMapOutput
}

type CryptoWalletMap map[string]CryptoWalletInput

func (CryptoWalletMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CryptoWallet)(nil)).Elem()
}

func (i CryptoWalletMap) ToCryptoWalletMapOutput() CryptoWalletMapOutput {
	return i.ToCryptoWalletMapOutputWithContext(context.Background())
}

func (i CryptoWalletMap) ToCryptoWalletMapOutputWithContext(ctx context.Context) CryptoWalletMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoWalletMapOutput)
}

type CryptoWalletOutput struct{ *pulumi.OutputState }

func (CryptoWalletOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoWallet)(nil)).Elem()
}

func (o CryptoWalletOutput) ToCryptoWalletOutput() CryptoWalletOutput {
	return o
}

func (o CryptoWalletOutput) ToCryptoWalletOutputWithContext(ctx context.Context) CryptoWalletOutput {
	return o
}

type CryptoWalletArrayOutput struct{ *pulumi.OutputState }

func (CryptoWalletArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CryptoWallet)(nil)).Elem()
}

func (o CryptoWalletArrayOutput) ToCryptoWalletArrayOutput() CryptoWalletArrayOutput {
	return o
}

func (o CryptoWalletArrayOutput) ToCryptoWalletArrayOutputWithContext(ctx context.Context) CryptoWalletArrayOutput {
	return o
}

func (o CryptoWalletArrayOutput) Index(i pulumi.IntInput) CryptoWalletOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CryptoWallet {
		return vs[0].([]*CryptoWallet)[vs[1].(int)]
	}).(CryptoWalletOutput)
}

type CryptoWalletMapOutput struct{ *pulumi.OutputState }

func (CryptoWalletMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CryptoWallet)(nil)).Elem()
}

func (o CryptoWalletMapOutput) ToCryptoWalletMapOutput() CryptoWalletMapOutput {
	return o
}

func (o CryptoWalletMapOutput) ToCryptoWalletMapOutputWithContext(ctx context.Context) CryptoWalletMapOutput {
	return o
}

func (o CryptoWalletMapOutput) MapIndex(k pulumi.StringInput) CryptoWalletOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CryptoWallet {
		return vs[0].(map[string]*CryptoWallet)[vs[1].(string)]
	}).(CryptoWalletOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoWalletInput)(nil)).Elem(), &CryptoWallet{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoWalletArrayInput)(nil)).Elem(), CryptoWalletArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoWalletMapInput)(nil)).Elem(), CryptoWalletMap{})
	pulumi.RegisterOutputType(CryptoWalletOutput{})
	pulumi.RegisterOutputType(CryptoWalletArrayOutput{})
	pulumi.RegisterOutputType(CryptoWalletMapOutput{})
}
