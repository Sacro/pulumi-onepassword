// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package onepassword

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Login struct {
	pulumi.CustomResourceState

	Category pulumi.StringOutput    `pulumi:"category"`
	Fields   GetFieldArrayOutput    `pulumi:"fields"`
	Id       pulumi.StringOutput    `pulumi:"id"`
	Notes    pulumi.StringPtrOutput `pulumi:"notes"`
	Password pulumi.StringPtrOutput `pulumi:"password"`
	Sections GetSectionArrayOutput  `pulumi:"sections"`
	// An array of strings of the tags assigned to the item.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The title of the item.
	Title    pulumi.StringOutput    `pulumi:"title"`
	Username pulumi.StringPtrOutput `pulumi:"username"`
	// The UUID of the item to retrieve. This field will be populated with the UUID of the item if the item it looked up by its title.
	Uuid pulumi.StringOutput `pulumi:"uuid"`
	// The UUID of the vault the item is in.
	Vault pulumi.StringOutput `pulumi:"vault"`
}

// NewLogin registers a new resource with the given unique name, arguments, and options.
func NewLogin(ctx *pulumi.Context,
	name string, args *LoginArgs, opts ...pulumi.ResourceOption) (*Login, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Title == nil {
		return nil, errors.New("invalid value for required argument 'Title'")
	}
	if args.Vault == nil {
		return nil, errors.New("invalid value for required argument 'Vault'")
	}
	if args.Password != nil {
		args.Password = pulumi.ToSecret(args.Password).(pulumi.StringPtrOutput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
	})
	opts = append(opts, secrets)
	var resource Login
	err := ctx.RegisterResource("onepassword:index:Login", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogin gets an existing Login resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogin(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LoginState, opts ...pulumi.ResourceOption) (*Login, error) {
	var resource Login
	err := ctx.ReadResource("onepassword:index:Login", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Login resources.
type loginState struct {
}

type LoginState struct {
}

func (LoginState) ElementType() reflect.Type {
	return reflect.TypeOf((*loginState)(nil)).Elem()
}

type loginArgs struct {
	Fields   []Field   `pulumi:"fields"`
	Notes    *string   `pulumi:"notes"`
	Password *string   `pulumi:"password"`
	Sections []Section `pulumi:"sections"`
	// An array of strings of the tags assigned to the item.
	Tags []string `pulumi:"tags"`
	// The title of the item to retrieve. This field will be populated with the title of the item if the item it looked up by its UUID.
	Title    string  `pulumi:"title"`
	Username *string `pulumi:"username"`
	// The UUID of the vault the item is in.
	Vault string `pulumi:"vault"`
}

// The set of arguments for constructing a Login resource.
type LoginArgs struct {
	Fields   FieldArrayInput
	Notes    pulumi.StringPtrInput
	Password pulumi.StringPtrInput
	Sections SectionArrayInput
	// An array of strings of the tags assigned to the item.
	Tags pulumi.StringArrayInput
	// The title of the item to retrieve. This field will be populated with the title of the item if the item it looked up by its UUID.
	Title    pulumi.StringInput
	Username pulumi.StringPtrInput
	// The UUID of the vault the item is in.
	Vault pulumi.StringInput
}

func (LoginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*loginArgs)(nil)).Elem()
}

type LoginInput interface {
	pulumi.Input

	ToLoginOutput() LoginOutput
	ToLoginOutputWithContext(ctx context.Context) LoginOutput
}

func (*Login) ElementType() reflect.Type {
	return reflect.TypeOf((**Login)(nil)).Elem()
}

func (i *Login) ToLoginOutput() LoginOutput {
	return i.ToLoginOutputWithContext(context.Background())
}

func (i *Login) ToLoginOutputWithContext(ctx context.Context) LoginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoginOutput)
}

// LoginArrayInput is an input type that accepts LoginArray and LoginArrayOutput values.
// You can construct a concrete instance of `LoginArrayInput` via:
//
//	LoginArray{ LoginArgs{...} }
type LoginArrayInput interface {
	pulumi.Input

	ToLoginArrayOutput() LoginArrayOutput
	ToLoginArrayOutputWithContext(context.Context) LoginArrayOutput
}

type LoginArray []LoginInput

func (LoginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Login)(nil)).Elem()
}

func (i LoginArray) ToLoginArrayOutput() LoginArrayOutput {
	return i.ToLoginArrayOutputWithContext(context.Background())
}

func (i LoginArray) ToLoginArrayOutputWithContext(ctx context.Context) LoginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoginArrayOutput)
}

// LoginMapInput is an input type that accepts LoginMap and LoginMapOutput values.
// You can construct a concrete instance of `LoginMapInput` via:
//
//	LoginMap{ "key": LoginArgs{...} }
type LoginMapInput interface {
	pulumi.Input

	ToLoginMapOutput() LoginMapOutput
	ToLoginMapOutputWithContext(context.Context) LoginMapOutput
}

type LoginMap map[string]LoginInput

func (LoginMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Login)(nil)).Elem()
}

func (i LoginMap) ToLoginMapOutput() LoginMapOutput {
	return i.ToLoginMapOutputWithContext(context.Background())
}

func (i LoginMap) ToLoginMapOutputWithContext(ctx context.Context) LoginMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoginMapOutput)
}

type LoginOutput struct{ *pulumi.OutputState }

func (LoginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Login)(nil)).Elem()
}

func (o LoginOutput) ToLoginOutput() LoginOutput {
	return o
}

func (o LoginOutput) ToLoginOutputWithContext(ctx context.Context) LoginOutput {
	return o
}

type LoginArrayOutput struct{ *pulumi.OutputState }

func (LoginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Login)(nil)).Elem()
}

func (o LoginArrayOutput) ToLoginArrayOutput() LoginArrayOutput {
	return o
}

func (o LoginArrayOutput) ToLoginArrayOutputWithContext(ctx context.Context) LoginArrayOutput {
	return o
}

func (o LoginArrayOutput) Index(i pulumi.IntInput) LoginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Login {
		return vs[0].([]*Login)[vs[1].(int)]
	}).(LoginOutput)
}

type LoginMapOutput struct{ *pulumi.OutputState }

func (LoginMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Login)(nil)).Elem()
}

func (o LoginMapOutput) ToLoginMapOutput() LoginMapOutput {
	return o
}

func (o LoginMapOutput) ToLoginMapOutputWithContext(ctx context.Context) LoginMapOutput {
	return o
}

func (o LoginMapOutput) MapIndex(k pulumi.StringInput) LoginOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Login {
		return vs[0].(map[string]*Login)[vs[1].(string)]
	}).(LoginOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LoginInput)(nil)).Elem(), &Login{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoginArrayInput)(nil)).Elem(), LoginArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoginMapInput)(nil)).Elem(), LoginMap{})
	pulumi.RegisterOutputType(LoginOutput{})
	pulumi.RegisterOutputType(LoginArrayOutput{})
	pulumi.RegisterOutputType(LoginMapOutput{})
}
